/* automatically generated by rust-bindgen 0.59.2 */

pub const MQTT_STATE_ARRAY_MAX_COUNT: u32 = 10;
pub const MQTT_MAX_CONNACK_RECEIVE_RETRY_COUNT: u32 = 5;
pub const MQTT_PINGRESP_TIMEOUT_MS: u32 = 5000;
pub const MQTT_RECV_POLLING_TIMEOUT_MS: u32 = 10;
pub const MQTT_SEND_RETRY_TIMEOUT_MS: u32 = 10;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const MQTT_PUBLISH_ACK_PACKET_SIZE: u32 = 4;
pub const MQTT_LIBRARY_VERSION: &[u8; 7usize] = b"v1.2.0\0";
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NetworkContext {
    _unused: [u8; 0],
}
pub type NetworkContext_t = NetworkContext;
pub type TransportRecv_t = ::std::option::Option<
    unsafe extern "C" fn(
        pNetworkContext: *mut NetworkContext_t,
        pBuffer: *mut ::std::os::raw::c_void,
        bytesToRecv: size_t,
    ) -> i32,
>;
pub type TransportSend_t = ::std::option::Option<
    unsafe extern "C" fn(
        pNetworkContext: *mut NetworkContext_t,
        pBuffer: *const ::std::os::raw::c_void,
        bytesToSend: size_t,
    ) -> i32,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TransportInterface {
    #[doc = "< Transport receive interface."]
    pub recv: TransportRecv_t,
    #[doc = "< Transport send interface."]
    pub send: TransportSend_t,
    #[doc = "< Implementation-defined network context."]
    pub pNetworkContext: *mut NetworkContext_t,
}
#[test]
fn bindgen_test_layout_TransportInterface() {
    assert_eq!(
        ::std::mem::size_of::<TransportInterface>(),
        24usize,
        concat!("Size of: ", stringify!(TransportInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<TransportInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(TransportInterface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TransportInterface>())).recv as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TransportInterface),
            "::",
            stringify!(recv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TransportInterface>())).send as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TransportInterface),
            "::",
            stringify!(send)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TransportInterface>())).pNetworkContext as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TransportInterface),
            "::",
            stringify!(pNetworkContext)
        )
    );
}
pub type TransportInterface_t = TransportInterface;
#[doc = "< Function completed successfully."]
pub const MQTTStatus_MQTTSuccess: MQTTStatus = 0;
#[doc = "< At least one parameter was invalid."]
pub const MQTTStatus_MQTTBadParameter: MQTTStatus = 1;
#[doc = "< A provided buffer was too small."]
pub const MQTTStatus_MQTTNoMemory: MQTTStatus = 2;
#[doc = "< The transport send function failed."]
pub const MQTTStatus_MQTTSendFailed: MQTTStatus = 3;
#[doc = "< The transport receive function failed."]
pub const MQTTStatus_MQTTRecvFailed: MQTTStatus = 4;
#[doc = "< An invalid packet was received from the server."]
pub const MQTTStatus_MQTTBadResponse: MQTTStatus = 5;
#[doc = "< The server refused a CONNECT or SUBSCRIBE."]
pub const MQTTStatus_MQTTServerRefused: MQTTStatus = 6;
#[doc = "< No data available from the transport interface."]
pub const MQTTStatus_MQTTNoDataAvailable: MQTTStatus = 7;
#[doc = "< An illegal state in the state record."]
pub const MQTTStatus_MQTTIllegalState: MQTTStatus = 8;
#[doc = "< A collision with an existing state record entry."]
pub const MQTTStatus_MQTTStateCollision: MQTTStatus = 9;
#[doc = "< Timeout while waiting for PINGRESP."]
pub const MQTTStatus_MQTTKeepAliveTimeout: MQTTStatus = 10;
#[doc = " @ingroup mqtt_enum_types"]
#[doc = " @brief Return codes from MQTT functions."]
pub type MQTTStatus = ::std::os::raw::c_uint;
#[doc = " @ingroup mqtt_enum_types"]
#[doc = " @brief Return codes from MQTT functions."]
pub use self::MQTTStatus as MQTTStatus_t;
#[doc = "< Delivery at most once."]
pub const MQTTQoS_MQTTQoS0: MQTTQoS = 0;
#[doc = "< Delivery at least once."]
pub const MQTTQoS_MQTTQoS1: MQTTQoS = 1;
#[doc = "< Delivery exactly once."]
pub const MQTTQoS_MQTTQoS2: MQTTQoS = 2;
#[doc = " @ingroup mqtt_enum_types"]
#[doc = " @brief MQTT Quality of Service values."]
pub type MQTTQoS = ::std::os::raw::c_uint;
#[doc = " @ingroup mqtt_enum_types"]
#[doc = " @brief MQTT Quality of Service values."]
pub use self::MQTTQoS as MQTTQoS_t;
#[doc = " @ingroup mqtt_struct_types"]
#[doc = " @brief Buffer passed to MQTT library."]
#[doc = ""]
#[doc = " These buffers are not copied and must remain in scope for the duration of the"]
#[doc = " MQTT operation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTFixedBuffer {
    #[doc = "< @brief Pointer to buffer."]
    pub pBuffer: *mut u8,
    #[doc = "< @brief Size of buffer."]
    pub size: size_t,
}
#[test]
fn bindgen_test_layout_MQTTFixedBuffer() {
    assert_eq!(
        ::std::mem::size_of::<MQTTFixedBuffer>(),
        16usize,
        concat!("Size of: ", stringify!(MQTTFixedBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTFixedBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(MQTTFixedBuffer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTFixedBuffer>())).pBuffer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTFixedBuffer),
            "::",
            stringify!(pBuffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTFixedBuffer>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTFixedBuffer),
            "::",
            stringify!(size)
        )
    );
}
#[doc = " @ingroup mqtt_struct_types"]
#[doc = " @brief Buffer passed to MQTT library."]
#[doc = ""]
#[doc = " These buffers are not copied and must remain in scope for the duration of the"]
#[doc = " MQTT operation."]
pub type MQTTFixedBuffer_t = MQTTFixedBuffer;
#[doc = " @ingroup mqtt_struct_types"]
#[doc = " @brief MQTT CONNECT packet parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTConnectInfo {
    #[doc = " @brief Whether to establish a new, clean session or resume a previous session."]
    pub cleanSession: bool,
    #[doc = " @brief MQTT keep alive period."]
    pub keepAliveSeconds: u16,
    #[doc = " @brief MQTT client identifier. Must be unique per client."]
    pub pClientIdentifier: *const ::std::os::raw::c_char,
    #[doc = " @brief Length of the client identifier."]
    pub clientIdentifierLength: u16,
    #[doc = " @brief MQTT user name. Set to NULL if not used."]
    pub pUserName: *const ::std::os::raw::c_char,
    #[doc = " @brief Length of MQTT user name. Set to 0 if not used."]
    pub userNameLength: u16,
    #[doc = " @brief MQTT password. Set to NULL if not used."]
    pub pPassword: *const ::std::os::raw::c_char,
    #[doc = " @brief Length of MQTT password. Set to 0 if not used."]
    pub passwordLength: u16,
}
#[test]
fn bindgen_test_layout_MQTTConnectInfo() {
    assert_eq!(
        ::std::mem::size_of::<MQTTConnectInfo>(),
        56usize,
        concat!("Size of: ", stringify!(MQTTConnectInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTConnectInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(MQTTConnectInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTConnectInfo>())).cleanSession as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTConnectInfo),
            "::",
            stringify!(cleanSession)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTConnectInfo>())).keepAliveSeconds as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTConnectInfo),
            "::",
            stringify!(keepAliveSeconds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTConnectInfo>())).pClientIdentifier as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTConnectInfo),
            "::",
            stringify!(pClientIdentifier)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTConnectInfo>())).clientIdentifierLength as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTConnectInfo),
            "::",
            stringify!(clientIdentifierLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTConnectInfo>())).pUserName as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTConnectInfo),
            "::",
            stringify!(pUserName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTConnectInfo>())).userNameLength as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTConnectInfo),
            "::",
            stringify!(userNameLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTConnectInfo>())).pPassword as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTConnectInfo),
            "::",
            stringify!(pPassword)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTConnectInfo>())).passwordLength as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTConnectInfo),
            "::",
            stringify!(passwordLength)
        )
    );
}
#[doc = " @ingroup mqtt_struct_types"]
#[doc = " @brief MQTT CONNECT packet parameters."]
pub type MQTTConnectInfo_t = MQTTConnectInfo;
#[doc = " @ingroup mqtt_struct_types"]
#[doc = " @brief MQTT SUBSCRIBE packet parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTSubscribeInfo {
    #[doc = " @brief Quality of Service for subscription."]
    pub qos: MQTTQoS_t,
    #[doc = " @brief Topic filter to subscribe to."]
    pub pTopicFilter: *const ::std::os::raw::c_char,
    #[doc = " @brief Length of subscription topic filter."]
    pub topicFilterLength: u16,
}
#[test]
fn bindgen_test_layout_MQTTSubscribeInfo() {
    assert_eq!(
        ::std::mem::size_of::<MQTTSubscribeInfo>(),
        24usize,
        concat!("Size of: ", stringify!(MQTTSubscribeInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTSubscribeInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(MQTTSubscribeInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTSubscribeInfo>())).qos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTSubscribeInfo),
            "::",
            stringify!(qos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTSubscribeInfo>())).pTopicFilter as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTSubscribeInfo),
            "::",
            stringify!(pTopicFilter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTSubscribeInfo>())).topicFilterLength as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTSubscribeInfo),
            "::",
            stringify!(topicFilterLength)
        )
    );
}
#[doc = " @ingroup mqtt_struct_types"]
#[doc = " @brief MQTT SUBSCRIBE packet parameters."]
pub type MQTTSubscribeInfo_t = MQTTSubscribeInfo;
#[doc = " @ingroup mqtt_struct_types"]
#[doc = " @brief MQTT PUBLISH packet parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTPublishInfo {
    #[doc = " @brief Quality of Service for message."]
    pub qos: MQTTQoS_t,
    #[doc = " @brief Whether this is a retained message."]
    pub retain: bool,
    #[doc = " @brief Whether this is a duplicate publish message."]
    pub dup: bool,
    #[doc = " @brief Topic name on which the message is published."]
    pub pTopicName: *const ::std::os::raw::c_char,
    #[doc = " @brief Length of topic name."]
    pub topicNameLength: u16,
    #[doc = " @brief Message payload."]
    pub pPayload: *const ::std::os::raw::c_void,
    #[doc = " @brief Message payload length."]
    pub payloadLength: size_t,
}
#[test]
fn bindgen_test_layout_MQTTPublishInfo() {
    assert_eq!(
        ::std::mem::size_of::<MQTTPublishInfo>(),
        40usize,
        concat!("Size of: ", stringify!(MQTTPublishInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTPublishInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(MQTTPublishInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTPublishInfo>())).qos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTPublishInfo),
            "::",
            stringify!(qos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTPublishInfo>())).retain as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTPublishInfo),
            "::",
            stringify!(retain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTPublishInfo>())).dup as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTPublishInfo),
            "::",
            stringify!(dup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTPublishInfo>())).pTopicName as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTPublishInfo),
            "::",
            stringify!(pTopicName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTPublishInfo>())).topicNameLength as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTPublishInfo),
            "::",
            stringify!(topicNameLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTPublishInfo>())).pPayload as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTPublishInfo),
            "::",
            stringify!(pPayload)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTPublishInfo>())).payloadLength as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTPublishInfo),
            "::",
            stringify!(payloadLength)
        )
    );
}
#[doc = " @ingroup mqtt_struct_types"]
#[doc = " @brief MQTT PUBLISH packet parameters."]
pub type MQTTPublishInfo_t = MQTTPublishInfo;
#[doc = " @ingroup mqtt_struct_types"]
#[doc = " @brief MQTT incoming packet parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTPacketInfo {
    #[doc = " @brief Type of incoming MQTT packet."]
    pub type_: u8,
    #[doc = " @brief Remaining serialized data in the MQTT packet."]
    pub pRemainingData: *mut u8,
    #[doc = " @brief Length of remaining serialized data."]
    pub remainingLength: size_t,
}
#[test]
fn bindgen_test_layout_MQTTPacketInfo() {
    assert_eq!(
        ::std::mem::size_of::<MQTTPacketInfo>(),
        24usize,
        concat!("Size of: ", stringify!(MQTTPacketInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTPacketInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(MQTTPacketInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTPacketInfo>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTPacketInfo),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTPacketInfo>())).pRemainingData as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTPacketInfo),
            "::",
            stringify!(pRemainingData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTPacketInfo>())).remainingLength as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTPacketInfo),
            "::",
            stringify!(remainingLength)
        )
    );
}
#[doc = " @ingroup mqtt_struct_types"]
#[doc = " @brief MQTT incoming packet parameters."]
pub type MQTTPacketInfo_t = MQTTPacketInfo;
extern "C" {
    pub fn MQTT_GetConnectPacketSize(
        pConnectInfo: *const MQTTConnectInfo_t,
        pWillInfo: *const MQTTPublishInfo_t,
        pRemainingLength: *mut size_t,
        pPacketSize: *mut size_t,
    ) -> MQTTStatus_t;
}
extern "C" {
    pub fn MQTT_SerializeConnect(
        pConnectInfo: *const MQTTConnectInfo_t,
        pWillInfo: *const MQTTPublishInfo_t,
        remainingLength: size_t,
        pFixedBuffer: *const MQTTFixedBuffer_t,
    ) -> MQTTStatus_t;
}
extern "C" {
    pub fn MQTT_GetSubscribePacketSize(
        pSubscriptionList: *const MQTTSubscribeInfo_t,
        subscriptionCount: size_t,
        pRemainingLength: *mut size_t,
        pPacketSize: *mut size_t,
    ) -> MQTTStatus_t;
}
extern "C" {
    pub fn MQTT_SerializeSubscribe(
        pSubscriptionList: *const MQTTSubscribeInfo_t,
        subscriptionCount: size_t,
        packetId: u16,
        remainingLength: size_t,
        pFixedBuffer: *const MQTTFixedBuffer_t,
    ) -> MQTTStatus_t;
}
extern "C" {
    pub fn MQTT_GetUnsubscribePacketSize(
        pSubscriptionList: *const MQTTSubscribeInfo_t,
        subscriptionCount: size_t,
        pRemainingLength: *mut size_t,
        pPacketSize: *mut size_t,
    ) -> MQTTStatus_t;
}
extern "C" {
    pub fn MQTT_SerializeUnsubscribe(
        pSubscriptionList: *const MQTTSubscribeInfo_t,
        subscriptionCount: size_t,
        packetId: u16,
        remainingLength: size_t,
        pFixedBuffer: *const MQTTFixedBuffer_t,
    ) -> MQTTStatus_t;
}
extern "C" {
    pub fn MQTT_GetPublishPacketSize(
        pPublishInfo: *const MQTTPublishInfo_t,
        pRemainingLength: *mut size_t,
        pPacketSize: *mut size_t,
    ) -> MQTTStatus_t;
}
extern "C" {
    pub fn MQTT_SerializePublish(
        pPublishInfo: *const MQTTPublishInfo_t,
        packetId: u16,
        remainingLength: size_t,
        pFixedBuffer: *const MQTTFixedBuffer_t,
    ) -> MQTTStatus_t;
}
extern "C" {
    pub fn MQTT_SerializePublishHeader(
        pPublishInfo: *const MQTTPublishInfo_t,
        packetId: u16,
        remainingLength: size_t,
        pFixedBuffer: *const MQTTFixedBuffer_t,
        pHeaderSize: *mut size_t,
    ) -> MQTTStatus_t;
}
extern "C" {
    pub fn MQTT_SerializeAck(
        pFixedBuffer: *const MQTTFixedBuffer_t,
        packetType: u8,
        packetId: u16,
    ) -> MQTTStatus_t;
}
extern "C" {
    pub fn MQTT_GetDisconnectPacketSize(pPacketSize: *mut size_t) -> MQTTStatus_t;
}
extern "C" {
    pub fn MQTT_SerializeDisconnect(pFixedBuffer: *const MQTTFixedBuffer_t) -> MQTTStatus_t;
}
extern "C" {
    pub fn MQTT_GetPingreqPacketSize(pPacketSize: *mut size_t) -> MQTTStatus_t;
}
extern "C" {
    pub fn MQTT_SerializePingreq(pFixedBuffer: *const MQTTFixedBuffer_t) -> MQTTStatus_t;
}
extern "C" {
    pub fn MQTT_DeserializePublish(
        pIncomingPacket: *const MQTTPacketInfo_t,
        pPacketId: *mut u16,
        pPublishInfo: *mut MQTTPublishInfo_t,
    ) -> MQTTStatus_t;
}
extern "C" {
    pub fn MQTT_DeserializeAck(
        pIncomingPacket: *const MQTTPacketInfo_t,
        pPacketId: *mut u16,
        pSessionPresent: *mut bool,
    ) -> MQTTStatus_t;
}
extern "C" {
    pub fn MQTT_GetIncomingPacketTypeAndLength(
        readFunc: TransportRecv_t,
        pNetworkContext: *mut NetworkContext_t,
        pIncomingPacket: *mut MQTTPacketInfo_t,
    ) -> MQTTStatus_t;
}
#[doc = " @ingroup mqtt_callback_types"]
#[doc = " @brief Application provided function to query the current time in"]
#[doc = " milliseconds."]
#[doc = ""]
#[doc = " @return The current time in milliseconds."]
pub type MQTTGetCurrentTimeFunc_t = ::std::option::Option<unsafe extern "C" fn() -> u32>;
#[doc = " @ingroup mqtt_callback_types"]
#[doc = " @brief Application callback for receiving incoming publishes and incoming"]
#[doc = " acks."]
#[doc = ""]
#[doc = " @note This callback will be called only if packets are deserialized with a"]
#[doc = " result of #MQTTSuccess or #MQTTServerRefused. The latter can be obtained"]
#[doc = " when deserializing a SUBACK, indicating a broker's rejection of a subscribe."]
#[doc = ""]
#[doc = " @param[in] pContext Initialized MQTT context."]
#[doc = " @param[in] pPacketInfo Information on the type of incoming MQTT packet."]
#[doc = " @param[in] pDeserializedInfo Deserialized information from incoming packet."]
pub type MQTTEventCallback_t = ::std::option::Option<
    unsafe extern "C" fn(
        pContext: *mut MQTTContext,
        pPacketInfo: *mut MQTTPacketInfo,
        pDeserializedInfo: *mut MQTTDeserializedInfo,
    ),
>;
#[doc = "< @brief MQTT Connection is inactive."]
pub const MQTTConnectionStatus_MQTTNotConnected: MQTTConnectionStatus = 0;
#[doc = "< @brief MQTT Connection is active."]
pub const MQTTConnectionStatus_MQTTConnected: MQTTConnectionStatus = 1;
#[doc = " @ingroup mqtt_enum_types"]
#[doc = " @brief Values indicating if an MQTT connection exists."]
pub type MQTTConnectionStatus = ::std::os::raw::c_uint;
#[doc = " @ingroup mqtt_enum_types"]
#[doc = " @brief Values indicating if an MQTT connection exists."]
pub use self::MQTTConnectionStatus as MQTTConnectionStatus_t;
#[doc = "< @brief An empty state with no corresponding PUBLISH."]
pub const MQTTPublishState_MQTTStateNull: MQTTPublishState = 0;
#[doc = "< @brief The library will send an outgoing PUBLISH packet."]
pub const MQTTPublishState_MQTTPublishSend: MQTTPublishState = 1;
#[doc = "< @brief The library will send a PUBACK for a received PUBLISH."]
pub const MQTTPublishState_MQTTPubAckSend: MQTTPublishState = 2;
#[doc = "< @brief The library will send a PUBREC for a received PUBLISH."]
pub const MQTTPublishState_MQTTPubRecSend: MQTTPublishState = 3;
#[doc = "< @brief The library will send a PUBREL for a received PUBREC."]
pub const MQTTPublishState_MQTTPubRelSend: MQTTPublishState = 4;
#[doc = "< @brief The library will send a PUBCOMP for a received PUBREL."]
pub const MQTTPublishState_MQTTPubCompSend: MQTTPublishState = 5;
#[doc = "< @brief The library is awaiting a PUBACK for an outgoing PUBLISH."]
pub const MQTTPublishState_MQTTPubAckPending: MQTTPublishState = 6;
#[doc = "< @brief The library is awaiting a PUBREC for an outgoing PUBLISH."]
pub const MQTTPublishState_MQTTPubRecPending: MQTTPublishState = 7;
#[doc = "< @brief The library is awaiting a PUBREL for an incoming PUBLISH."]
pub const MQTTPublishState_MQTTPubRelPending: MQTTPublishState = 8;
#[doc = "< @brief The library is awaiting a PUBCOMP for an outgoing PUBLISH."]
pub const MQTTPublishState_MQTTPubCompPending: MQTTPublishState = 9;
#[doc = "< @brief The PUBLISH has been completed."]
pub const MQTTPublishState_MQTTPublishDone: MQTTPublishState = 10;
#[doc = " @ingroup mqtt_enum_types"]
#[doc = " @brief The state of QoS 1 or QoS 2 MQTT publishes, used in the state engine."]
pub type MQTTPublishState = ::std::os::raw::c_uint;
#[doc = " @ingroup mqtt_enum_types"]
#[doc = " @brief The state of QoS 1 or QoS 2 MQTT publishes, used in the state engine."]
pub use self::MQTTPublishState as MQTTPublishState_t;
#[doc = "< @brief PUBACKs are sent in response to a QoS 1 PUBLISH."]
pub const MQTTPubAckType_MQTTPuback: MQTTPubAckType = 0;
#[doc = "< @brief PUBRECs are sent in response to a QoS 2 PUBLISH."]
pub const MQTTPubAckType_MQTTPubrec: MQTTPubAckType = 1;
#[doc = "< @brief PUBRELs are sent in response to a PUBREC."]
pub const MQTTPubAckType_MQTTPubrel: MQTTPubAckType = 2;
#[doc = "< @brief PUBCOMPs are sent in response to a PUBREL."]
pub const MQTTPubAckType_MQTTPubcomp: MQTTPubAckType = 3;
#[doc = " @ingroup mqtt_enum_types"]
#[doc = " @brief Packet types used in acknowledging QoS 1 or QoS 2 publishes."]
pub type MQTTPubAckType = ::std::os::raw::c_uint;
#[doc = " @ingroup mqtt_enum_types"]
#[doc = " @brief Packet types used in acknowledging QoS 1 or QoS 2 publishes."]
pub use self::MQTTPubAckType as MQTTPubAckType_t;
#[doc = "< @brief Success with a maximum delivery at QoS 0."]
pub const MQTTSubAckStatus_MQTTSubAckSuccessQos0: MQTTSubAckStatus = 0;
#[doc = "< @brief Success with a maximum delivery at QoS 1."]
pub const MQTTSubAckStatus_MQTTSubAckSuccessQos1: MQTTSubAckStatus = 1;
#[doc = "< @brief Success with a maximum delivery at QoS 2."]
pub const MQTTSubAckStatus_MQTTSubAckSuccessQos2: MQTTSubAckStatus = 2;
#[doc = "< @brief Failure."]
pub const MQTTSubAckStatus_MQTTSubAckFailure: MQTTSubAckStatus = 128;
#[doc = " @ingroup mqtt_enum_types"]
#[doc = " @brief The status codes in the SUBACK response to a subscription request."]
pub type MQTTSubAckStatus = ::std::os::raw::c_uint;
#[doc = " @ingroup mqtt_enum_types"]
#[doc = " @brief The status codes in the SUBACK response to a subscription request."]
pub use self::MQTTSubAckStatus as MQTTSubAckStatus_t;
#[doc = " @ingroup mqtt_struct_types"]
#[doc = " @brief An element of the state engine records for QoS 1 or Qos 2 publishes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTPubAckInfo {
    #[doc = "< @brief The packet ID of the original PUBLISH."]
    pub packetId: u16,
    #[doc = "< @brief The QoS of the original PUBLISH."]
    pub qos: MQTTQoS_t,
    #[doc = "< @brief The current state of the publish process."]
    pub publishState: MQTTPublishState_t,
}
#[test]
fn bindgen_test_layout_MQTTPubAckInfo() {
    assert_eq!(
        ::std::mem::size_of::<MQTTPubAckInfo>(),
        12usize,
        concat!("Size of: ", stringify!(MQTTPubAckInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTPubAckInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(MQTTPubAckInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTPubAckInfo>())).packetId as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTPubAckInfo),
            "::",
            stringify!(packetId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTPubAckInfo>())).qos as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTPubAckInfo),
            "::",
            stringify!(qos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTPubAckInfo>())).publishState as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTPubAckInfo),
            "::",
            stringify!(publishState)
        )
    );
}
#[doc = " @ingroup mqtt_struct_types"]
#[doc = " @brief An element of the state engine records for QoS 1 or Qos 2 publishes."]
pub type MQTTPubAckInfo_t = MQTTPubAckInfo;
#[doc = " @ingroup mqtt_struct_types"]
#[doc = " @brief A struct representing an MQTT connection."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTContext {
    #[doc = " @brief State engine records for outgoing publishes."]
    pub outgoingPublishRecords: [MQTTPubAckInfo_t; 10usize],
    #[doc = " @brief State engine records for incoming publishes."]
    pub incomingPublishRecords: [MQTTPubAckInfo_t; 10usize],
    #[doc = " @brief The transport interface used by the MQTT connection."]
    pub transportInterface: TransportInterface_t,
    #[doc = " @brief The buffer used in sending and receiving packets from the network."]
    pub networkBuffer: MQTTFixedBuffer_t,
    #[doc = " @brief The next available ID for outgoing MQTT packets."]
    pub nextPacketId: u16,
    #[doc = " @brief Whether the context currently has a connection to the broker."]
    pub connectStatus: MQTTConnectionStatus_t,
    #[doc = " @brief Function used to get millisecond timestamps."]
    pub getTime: MQTTGetCurrentTimeFunc_t,
    #[doc = " @brief Callback function used to give deserialized MQTT packets to the application."]
    pub appCallback: MQTTEventCallback_t,
    #[doc = " @brief Timestamp of the last packet sent by the library."]
    pub lastPacketTime: u32,
    #[doc = " @brief Whether the library sent a packet during a call of #MQTT_ProcessLoop or"]
    #[doc = " #MQTT_ReceiveLoop."]
    pub controlPacketSent: bool,
    #[doc = "< @brief Keep Alive interval."]
    pub keepAliveIntervalSec: u16,
    #[doc = "< @brief Timestamp of the last sent PINGREQ."]
    pub pingReqSendTimeMs: u32,
    #[doc = "< @brief If the library is currently awaiting a PINGRESP."]
    pub waitingForPingResp: bool,
}
#[test]
fn bindgen_test_layout_MQTTContext() {
    assert_eq!(
        ::std::mem::size_of::<MQTTContext>(),
        320usize,
        concat!("Size of: ", stringify!(MQTTContext))
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTContext>(),
        8usize,
        concat!("Alignment of ", stringify!(MQTTContext))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTContext>())).outgoingPublishRecords as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTContext),
            "::",
            stringify!(outgoingPublishRecords)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTContext>())).incomingPublishRecords as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTContext),
            "::",
            stringify!(incomingPublishRecords)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTContext>())).transportInterface as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTContext),
            "::",
            stringify!(transportInterface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTContext>())).networkBuffer as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTContext),
            "::",
            stringify!(networkBuffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTContext>())).nextPacketId as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTContext),
            "::",
            stringify!(nextPacketId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTContext>())).connectStatus as *const _ as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTContext),
            "::",
            stringify!(connectStatus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTContext>())).getTime as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTContext),
            "::",
            stringify!(getTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTContext>())).appCallback as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTContext),
            "::",
            stringify!(appCallback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTContext>())).lastPacketTime as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTContext),
            "::",
            stringify!(lastPacketTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTContext>())).controlPacketSent as *const _ as usize },
        308usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTContext),
            "::",
            stringify!(controlPacketSent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTContext>())).keepAliveIntervalSec as *const _ as usize
        },
        310usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTContext),
            "::",
            stringify!(keepAliveIntervalSec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTContext>())).pingReqSendTimeMs as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTContext),
            "::",
            stringify!(pingReqSendTimeMs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MQTTContext>())).waitingForPingResp as *const _ as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTContext),
            "::",
            stringify!(waitingForPingResp)
        )
    );
}
#[doc = " @ingroup mqtt_struct_types"]
#[doc = " @brief A struct representing an MQTT connection."]
pub type MQTTContext_t = MQTTContext;
#[doc = " @ingroup mqtt_struct_types"]
#[doc = " @brief Struct to hold deserialized packet information for an #MQTTEventCallback_t"]
#[doc = " callback."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MQTTDeserializedInfo {
    #[doc = "< @brief Packet ID of deserialized packet."]
    pub packetIdentifier: u16,
    #[doc = "< @brief Pointer to deserialized publish info."]
    pub pPublishInfo: *mut MQTTPublishInfo_t,
    #[doc = "< @brief Return code of deserialization."]
    pub deserializationResult: MQTTStatus_t,
}
#[test]
fn bindgen_test_layout_MQTTDeserializedInfo() {
    assert_eq!(
        ::std::mem::size_of::<MQTTDeserializedInfo>(),
        24usize,
        concat!("Size of: ", stringify!(MQTTDeserializedInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<MQTTDeserializedInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(MQTTDeserializedInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTDeserializedInfo>())).packetIdentifier as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTDeserializedInfo),
            "::",
            stringify!(packetIdentifier)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTDeserializedInfo>())).pPublishInfo as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTDeserializedInfo),
            "::",
            stringify!(pPublishInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MQTTDeserializedInfo>())).deserializationResult as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MQTTDeserializedInfo),
            "::",
            stringify!(deserializationResult)
        )
    );
}
#[doc = " @ingroup mqtt_struct_types"]
#[doc = " @brief Struct to hold deserialized packet information for an #MQTTEventCallback_t"]
#[doc = " callback."]
pub type MQTTDeserializedInfo_t = MQTTDeserializedInfo;
extern "C" {
    pub fn MQTT_Init(
        pContext: *mut MQTTContext_t,
        pTransportInterface: *const TransportInterface_t,
        getTimeFunction: MQTTGetCurrentTimeFunc_t,
        userCallback: MQTTEventCallback_t,
        pNetworkBuffer: *const MQTTFixedBuffer_t,
    ) -> MQTTStatus_t;
}
extern "C" {
    pub fn MQTT_Connect(
        pContext: *mut MQTTContext_t,
        pConnectInfo: *const MQTTConnectInfo_t,
        pWillInfo: *const MQTTPublishInfo_t,
        timeoutMs: u32,
        pSessionPresent: *mut bool,
    ) -> MQTTStatus_t;
}
extern "C" {
    pub fn MQTT_Subscribe(
        pContext: *mut MQTTContext_t,
        pSubscriptionList: *const MQTTSubscribeInfo_t,
        subscriptionCount: size_t,
        packetId: u16,
    ) -> MQTTStatus_t;
}
extern "C" {
    pub fn MQTT_Publish(
        pContext: *mut MQTTContext_t,
        pPublishInfo: *const MQTTPublishInfo_t,
        packetId: u16,
    ) -> MQTTStatus_t;
}
extern "C" {
    pub fn MQTT_Ping(pContext: *mut MQTTContext_t) -> MQTTStatus_t;
}
extern "C" {
    pub fn MQTT_Unsubscribe(
        pContext: *mut MQTTContext_t,
        pSubscriptionList: *const MQTTSubscribeInfo_t,
        subscriptionCount: size_t,
        packetId: u16,
    ) -> MQTTStatus_t;
}
extern "C" {
    pub fn MQTT_Disconnect(pContext: *mut MQTTContext_t) -> MQTTStatus_t;
}
extern "C" {
    pub fn MQTT_ProcessLoop(pContext: *mut MQTTContext_t, timeoutMs: u32) -> MQTTStatus_t;
}
extern "C" {
    pub fn MQTT_ReceiveLoop(pContext: *mut MQTTContext_t, timeoutMs: u32) -> MQTTStatus_t;
}
extern "C" {
    pub fn MQTT_GetPacketId(pContext: *mut MQTTContext_t) -> u16;
}
extern "C" {
    #[doc = " @brief A utility function that determines whether the passed topic filter and"]
    #[doc = " topic name match according to the MQTT 3.1.1 protocol specification."]
    #[doc = ""]
    #[doc = " @param[in] pTopicName The topic name to check."]
    #[doc = " @param[in] topicNameLength Length of the topic name."]
    #[doc = " @param[in] pTopicFilter The topic filter to check."]
    #[doc = " @param[in] topicFilterLength Length of topic filter."]
    #[doc = " @param[out] pIsMatch This is filled with the whether there"]
    #[doc = " exists a match or not."]
    #[doc = ""]
    #[doc = " @note The API assumes that the passed topic name is valid to meet the"]
    #[doc = " requirements of the MQTT 3.1.1 specification. Invalid topic names (for example,"]
    #[doc = " containing wildcard characters) should not be passed to the function."]
    #[doc = " Also, the API checks validity of topic filter for wildcard characters ONLY if"]
    #[doc = " the passed topic name and topic filter do not have an exact string match."]
    #[doc = ""]
    #[doc = " @return Returns one of the following:"]
    #[doc = " - #MQTTBadParameter, if any of the input parameters is invalid."]
    #[doc = " - #MQTTSuccess, if the matching operation was performed."]
    #[doc = ""]
    #[doc = " <b>Example</b>"]
    #[doc = " @code{c}"]
    #[doc = ""]
    #[doc = " // Variables used in this example."]
    #[doc = " const char * pTopic = \"topic/match/1\";"]
    #[doc = " const char * pFilter = \"topic/#\";"]
    #[doc = " MQTTStatus_t status = MQTTSuccess;"]
    #[doc = " bool match = false;"]
    #[doc = ""]
    #[doc = " status = MQTT_MatchTopic( pTopic, strlen( pTopic ), pFilter, strlen( pFilter ), &match );"]
    #[doc = " // Our parameters were valid, so this will return success."]
    #[doc = " assert( status == MQTTSuccess );"]
    #[doc = ""]
    #[doc = " // For this specific example, we already know this value is true. This"]
    #[doc = " // check is placed here as an example for use with variable topic names."]
    #[doc = " if( match )"]
    #[doc = " {"]
    #[doc = "      // Application can decide what to do with the matching topic name."]
    #[doc = " }"]
    #[doc = " @endcode"]
    pub fn MQTT_MatchTopic(
        pTopicName: *const ::std::os::raw::c_char,
        topicNameLength: u16,
        pTopicFilter: *const ::std::os::raw::c_char,
        topicFilterLength: u16,
        pIsMatch: *mut bool,
    ) -> MQTTStatus_t;
}
extern "C" {
    pub fn MQTT_GetSubAckStatusCodes(
        pSubackPacket: *const MQTTPacketInfo_t,
        pPayloadStart: *mut *mut u8,
        pPayloadSize: *mut size_t,
    ) -> MQTTStatus_t;
}
extern "C" {
    pub fn MQTT_Status_strerror(status: MQTTStatus_t) -> *const ::std::os::raw::c_char;
}
#[doc = " @ingroup mqtt_basic_types"]
#[doc = " @brief Cursor for iterating through state records."]
pub type MQTTStateCursor_t = size_t;
pub const MQTTStateOperation_MQTT_SEND: MQTTStateOperation = 0;
pub const MQTTStateOperation_MQTT_RECEIVE: MQTTStateOperation = 1;
#[doc = " @cond DOXYGEN_IGNORE"]
#[doc = " Doxygen should ignore this section, this enum is private."]
#[doc = ""]
#[doc = " @brief Value indicating either send or receive."]
pub type MQTTStateOperation = ::std::os::raw::c_uint;
#[doc = " @cond DOXYGEN_IGNORE"]
#[doc = " Doxygen should ignore this section, this enum is private."]
#[doc = ""]
#[doc = " @brief Value indicating either send or receive."]
pub use self::MQTTStateOperation as MQTTStateOperation_t;
extern "C" {
    #[doc = " @cond DOXYGEN_IGNORE"]
    #[doc = " Doxygen should ignore this definition, this function is private."]
    pub fn MQTT_ReserveState(
        pMqttContext: *mut MQTTContext_t,
        packetId: u16,
        qos: MQTTQoS_t,
    ) -> MQTTStatus_t;
}
extern "C" {
    #[doc = " @cond DOXYGEN_IGNORE"]
    #[doc = " Doxygen should ignore this definition, this function is private."]
    pub fn MQTT_CalculateStatePublish(
        opType: MQTTStateOperation_t,
        qos: MQTTQoS_t,
    ) -> MQTTPublishState_t;
}
extern "C" {
    #[doc = " @cond DOXYGEN_IGNORE"]
    #[doc = " Doxygen should ignore this definition, this function is private."]
    pub fn MQTT_UpdateStatePublish(
        pMqttContext: *mut MQTTContext_t,
        packetId: u16,
        opType: MQTTStateOperation_t,
        qos: MQTTQoS_t,
        pNewState: *mut MQTTPublishState_t,
    ) -> MQTTStatus_t;
}
extern "C" {
    #[doc = " @cond DOXYGEN_IGNORE"]
    #[doc = " Doxygen should ignore this definition, this function is private."]
    pub fn MQTT_CalculateStateAck(
        packetType: MQTTPubAckType_t,
        opType: MQTTStateOperation_t,
        qos: MQTTQoS_t,
    ) -> MQTTPublishState_t;
}
extern "C" {
    #[doc = " @cond DOXYGEN_IGNORE"]
    #[doc = " Doxygen should ignore this definition, this function is private."]
    pub fn MQTT_UpdateStateAck(
        pMqttContext: *mut MQTTContext_t,
        packetId: u16,
        packetType: MQTTPubAckType_t,
        opType: MQTTStateOperation_t,
        pNewState: *mut MQTTPublishState_t,
    ) -> MQTTStatus_t;
}
extern "C" {
    #[doc = " @cond DOXYGEN_IGNORE"]
    #[doc = " Doxygen should ignore this definition, this function is private."]
    pub fn MQTT_PubrelToResend(
        pMqttContext: *const MQTTContext_t,
        pCursor: *mut MQTTStateCursor_t,
        pState: *mut MQTTPublishState_t,
    ) -> u16;
}
extern "C" {
    pub fn MQTT_PublishToResend(
        pMqttContext: *const MQTTContext_t,
        pCursor: *mut MQTTStateCursor_t,
    ) -> u16;
}
extern "C" {
    #[doc = " @cond DOXYGEN_IGNORE"]
    #[doc = " Doxygen should ignore this definition, this function is private."]
    pub fn MQTT_State_strerror(state: MQTTPublishState_t) -> *const ::std::os::raw::c_char;
}
